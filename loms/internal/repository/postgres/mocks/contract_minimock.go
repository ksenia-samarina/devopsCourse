package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"devopsCourse/internal/domains/order/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContractMock implements postgres.Contract
type ContractMock struct {
	t minimock.Tester

	funcCntStocks          func(ctx context.Context, skus []uint32) (sa1 []model.Stock, err error)
	inspectFuncCntStocks   func(ctx context.Context, skus []uint32)
	afterCntStocksCounter  uint64
	beforeCntStocksCounter uint64
	CntStocksMock          mContractMockCntStocks

	funcCreateOrder          func(ctx context.Context, userID int64) (i1 int64, err error)
	inspectFuncCreateOrder   func(ctx context.Context, userID int64)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mContractMockCreateOrder

	funcListOrder          func(ctx context.Context, orderID int64) (l1 model.ListOrder, err error)
	inspectFuncListOrder   func(ctx context.Context, orderID int64)
	afterListOrderCounter  uint64
	beforeListOrderCounter uint64
	ListOrderMock          mContractMockListOrder

	funcReserveStocks          func(ctx context.Context, orderId int64, reserveStocks []model.Stock) (err error)
	inspectFuncReserveStocks   func(ctx context.Context, orderId int64, reserveStocks []model.Stock)
	afterReserveStocksCounter  uint64
	beforeReserveStocksCounter uint64
	ReserveStocksMock          mContractMockReserveStocks

	funcUpdateOrderStatus          func(ctx context.Context, orderID int64, status model.StatusOrder) (err error)
	inspectFuncUpdateOrderStatus   func(ctx context.Context, orderID int64, status model.StatusOrder)
	afterUpdateOrderStatusCounter  uint64
	beforeUpdateOrderStatusCounter uint64
	UpdateOrderStatusMock          mContractMockUpdateOrderStatus

	funcUpdateStocksReservationStatus          func(ctx context.Context, orderID int64, status model.StatusStockReservation) (err error)
	inspectFuncUpdateStocksReservationStatus   func(ctx context.Context, orderID int64, status model.StatusStockReservation)
	afterUpdateStocksReservationStatusCounter  uint64
	beforeUpdateStocksReservationStatusCounter uint64
	UpdateStocksReservationStatusMock          mContractMockUpdateStocksReservationStatus
}

// NewContractMock returns a mock for postgres.Contract
func NewContractMock(t minimock.Tester) *ContractMock {
	m := &ContractMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CntStocksMock = mContractMockCntStocks{mock: m}
	m.CntStocksMock.callArgs = []*ContractMockCntStocksParams{}

	m.CreateOrderMock = mContractMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*ContractMockCreateOrderParams{}

	m.ListOrderMock = mContractMockListOrder{mock: m}
	m.ListOrderMock.callArgs = []*ContractMockListOrderParams{}

	m.ReserveStocksMock = mContractMockReserveStocks{mock: m}
	m.ReserveStocksMock.callArgs = []*ContractMockReserveStocksParams{}

	m.UpdateOrderStatusMock = mContractMockUpdateOrderStatus{mock: m}
	m.UpdateOrderStatusMock.callArgs = []*ContractMockUpdateOrderStatusParams{}

	m.UpdateStocksReservationStatusMock = mContractMockUpdateStocksReservationStatus{mock: m}
	m.UpdateStocksReservationStatusMock.callArgs = []*ContractMockUpdateStocksReservationStatusParams{}

	return m
}

type mContractMockCntStocks struct {
	mock               *ContractMock
	defaultExpectation *ContractMockCntStocksExpectation
	expectations       []*ContractMockCntStocksExpectation

	callArgs []*ContractMockCntStocksParams
	mutex    sync.RWMutex
}

// ContractMockCntStocksExpectation specifies expectation struct of the Contract.CntStocks
type ContractMockCntStocksExpectation struct {
	mock    *ContractMock
	params  *ContractMockCntStocksParams
	results *ContractMockCntStocksResults
	Counter uint64
}

// ContractMockCntStocksParams contains parameters of the Contract.CntStocks
type ContractMockCntStocksParams struct {
	ctx  context.Context
	skus []uint32
}

// ContractMockCntStocksResults contains results of the Contract.CntStocks
type ContractMockCntStocksResults struct {
	sa1 []model.Stock
	err error
}

// Expect sets up expected params for Contract.CntStocks
func (mmCntStocks *mContractMockCntStocks) Expect(ctx context.Context, skus []uint32) *mContractMockCntStocks {
	if mmCntStocks.mock.funcCntStocks != nil {
		mmCntStocks.mock.t.Fatalf("ContractMock.CntStocks mock is already set by Set")
	}

	if mmCntStocks.defaultExpectation == nil {
		mmCntStocks.defaultExpectation = &ContractMockCntStocksExpectation{}
	}

	mmCntStocks.defaultExpectation.params = &ContractMockCntStocksParams{ctx, skus}
	for _, e := range mmCntStocks.expectations {
		if minimock.Equal(e.params, mmCntStocks.defaultExpectation.params) {
			mmCntStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCntStocks.defaultExpectation.params)
		}
	}

	return mmCntStocks
}

// Inspect accepts an inspector function that has same arguments as the Contract.CntStocks
func (mmCntStocks *mContractMockCntStocks) Inspect(f func(ctx context.Context, skus []uint32)) *mContractMockCntStocks {
	if mmCntStocks.mock.inspectFuncCntStocks != nil {
		mmCntStocks.mock.t.Fatalf("Inspect function is already set for ContractMock.CntStocks")
	}

	mmCntStocks.mock.inspectFuncCntStocks = f

	return mmCntStocks
}

// Return sets up results that will be returned by Contract.CntStocks
func (mmCntStocks *mContractMockCntStocks) Return(sa1 []model.Stock, err error) *ContractMock {
	if mmCntStocks.mock.funcCntStocks != nil {
		mmCntStocks.mock.t.Fatalf("ContractMock.CntStocks mock is already set by Set")
	}

	if mmCntStocks.defaultExpectation == nil {
		mmCntStocks.defaultExpectation = &ContractMockCntStocksExpectation{mock: mmCntStocks.mock}
	}
	mmCntStocks.defaultExpectation.results = &ContractMockCntStocksResults{sa1, err}
	return mmCntStocks.mock
}

// Set uses given function f to mock the Contract.CntStocks method
func (mmCntStocks *mContractMockCntStocks) Set(f func(ctx context.Context, skus []uint32) (sa1 []model.Stock, err error)) *ContractMock {
	if mmCntStocks.defaultExpectation != nil {
		mmCntStocks.mock.t.Fatalf("Default expectation is already set for the Contract.CntStocks method")
	}

	if len(mmCntStocks.expectations) > 0 {
		mmCntStocks.mock.t.Fatalf("Some expectations are already set for the Contract.CntStocks method")
	}

	mmCntStocks.mock.funcCntStocks = f
	return mmCntStocks.mock
}

// When sets expectation for the Contract.CntStocks which will trigger the result defined by the following
// Then helper
func (mmCntStocks *mContractMockCntStocks) When(ctx context.Context, skus []uint32) *ContractMockCntStocksExpectation {
	if mmCntStocks.mock.funcCntStocks != nil {
		mmCntStocks.mock.t.Fatalf("ContractMock.CntStocks mock is already set by Set")
	}

	expectation := &ContractMockCntStocksExpectation{
		mock:   mmCntStocks.mock,
		params: &ContractMockCntStocksParams{ctx, skus},
	}
	mmCntStocks.expectations = append(mmCntStocks.expectations, expectation)
	return expectation
}

// Then sets up Contract.CntStocks return parameters for the expectation previously defined by the When method
func (e *ContractMockCntStocksExpectation) Then(sa1 []model.Stock, err error) *ContractMock {
	e.results = &ContractMockCntStocksResults{sa1, err}
	return e.mock
}

// CntStocks implements postgres.Contract
func (mmCntStocks *ContractMock) CntStocks(ctx context.Context, skus []uint32) (sa1 []model.Stock, err error) {
	mm_atomic.AddUint64(&mmCntStocks.beforeCntStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmCntStocks.afterCntStocksCounter, 1)

	if mmCntStocks.inspectFuncCntStocks != nil {
		mmCntStocks.inspectFuncCntStocks(ctx, skus)
	}

	mm_params := &ContractMockCntStocksParams{ctx, skus}

	// Record call args
	mmCntStocks.CntStocksMock.mutex.Lock()
	mmCntStocks.CntStocksMock.callArgs = append(mmCntStocks.CntStocksMock.callArgs, mm_params)
	mmCntStocks.CntStocksMock.mutex.Unlock()

	for _, e := range mmCntStocks.CntStocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmCntStocks.CntStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCntStocks.CntStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmCntStocks.CntStocksMock.defaultExpectation.params
		mm_got := ContractMockCntStocksParams{ctx, skus}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCntStocks.t.Errorf("ContractMock.CntStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCntStocks.CntStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmCntStocks.t.Fatal("No results are set for the ContractMock.CntStocks")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmCntStocks.funcCntStocks != nil {
		return mmCntStocks.funcCntStocks(ctx, skus)
	}
	mmCntStocks.t.Fatalf("Unexpected call to ContractMock.CntStocks. %v %v", ctx, skus)
	return
}

// CntStocksAfterCounter returns a count of finished ContractMock.CntStocks invocations
func (mmCntStocks *ContractMock) CntStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCntStocks.afterCntStocksCounter)
}

// CntStocksBeforeCounter returns a count of ContractMock.CntStocks invocations
func (mmCntStocks *ContractMock) CntStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCntStocks.beforeCntStocksCounter)
}

// Calls returns a list of arguments used in each call to ContractMock.CntStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCntStocks *mContractMockCntStocks) Calls() []*ContractMockCntStocksParams {
	mmCntStocks.mutex.RLock()

	argCopy := make([]*ContractMockCntStocksParams, len(mmCntStocks.callArgs))
	copy(argCopy, mmCntStocks.callArgs)

	mmCntStocks.mutex.RUnlock()

	return argCopy
}

// MinimockCntStocksDone returns true if the count of the CntStocks invocations corresponds
// the number of defined expectations
func (m *ContractMock) MinimockCntStocksDone() bool {
	for _, e := range m.CntStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CntStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCntStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCntStocks != nil && mm_atomic.LoadUint64(&m.afterCntStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockCntStocksInspect logs each unmet expectation
func (m *ContractMock) MinimockCntStocksInspect() {
	for _, e := range m.CntStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractMock.CntStocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CntStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCntStocksCounter) < 1 {
		if m.CntStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractMock.CntStocks")
		} else {
			m.t.Errorf("Expected call to ContractMock.CntStocks with params: %#v", *m.CntStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCntStocks != nil && mm_atomic.LoadUint64(&m.afterCntStocksCounter) < 1 {
		m.t.Error("Expected call to ContractMock.CntStocks")
	}
}

type mContractMockCreateOrder struct {
	mock               *ContractMock
	defaultExpectation *ContractMockCreateOrderExpectation
	expectations       []*ContractMockCreateOrderExpectation

	callArgs []*ContractMockCreateOrderParams
	mutex    sync.RWMutex
}

// ContractMockCreateOrderExpectation specifies expectation struct of the Contract.CreateOrder
type ContractMockCreateOrderExpectation struct {
	mock    *ContractMock
	params  *ContractMockCreateOrderParams
	results *ContractMockCreateOrderResults
	Counter uint64
}

// ContractMockCreateOrderParams contains parameters of the Contract.CreateOrder
type ContractMockCreateOrderParams struct {
	ctx    context.Context
	userID int64
}

// ContractMockCreateOrderResults contains results of the Contract.CreateOrder
type ContractMockCreateOrderResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Contract.CreateOrder
func (mmCreateOrder *mContractMockCreateOrder) Expect(ctx context.Context, userID int64) *mContractMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ContractMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &ContractMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &ContractMockCreateOrderParams{ctx, userID}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Contract.CreateOrder
func (mmCreateOrder *mContractMockCreateOrder) Inspect(f func(ctx context.Context, userID int64)) *mContractMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for ContractMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Contract.CreateOrder
func (mmCreateOrder *mContractMockCreateOrder) Return(i1 int64, err error) *ContractMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ContractMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &ContractMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &ContractMockCreateOrderResults{i1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Contract.CreateOrder method
func (mmCreateOrder *mContractMockCreateOrder) Set(f func(ctx context.Context, userID int64) (i1 int64, err error)) *ContractMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Contract.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Contract.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the Contract.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mContractMockCreateOrder) When(ctx context.Context, userID int64) *ContractMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ContractMock.CreateOrder mock is already set by Set")
	}

	expectation := &ContractMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &ContractMockCreateOrderParams{ctx, userID},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Contract.CreateOrder return parameters for the expectation previously defined by the When method
func (e *ContractMockCreateOrderExpectation) Then(i1 int64, err error) *ContractMock {
	e.results = &ContractMockCreateOrderResults{i1, err}
	return e.mock
}

// CreateOrder implements postgres.Contract
func (mmCreateOrder *ContractMock) CreateOrder(ctx context.Context, userID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, userID)
	}

	mm_params := &ContractMockCreateOrderParams{ctx, userID}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := ContractMockCreateOrderParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("ContractMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the ContractMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, userID)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to ContractMock.CreateOrder. %v %v", ctx, userID)
	return
}

// CreateOrderAfterCounter returns a count of finished ContractMock.CreateOrder invocations
func (mmCreateOrder *ContractMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of ContractMock.CreateOrder invocations
func (mmCreateOrder *ContractMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to ContractMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mContractMockCreateOrder) Calls() []*ContractMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*ContractMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *ContractMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *ContractMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to ContractMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to ContractMock.CreateOrder")
	}
}

type mContractMockListOrder struct {
	mock               *ContractMock
	defaultExpectation *ContractMockListOrderExpectation
	expectations       []*ContractMockListOrderExpectation

	callArgs []*ContractMockListOrderParams
	mutex    sync.RWMutex
}

// ContractMockListOrderExpectation specifies expectation struct of the Contract.ListOrder
type ContractMockListOrderExpectation struct {
	mock    *ContractMock
	params  *ContractMockListOrderParams
	results *ContractMockListOrderResults
	Counter uint64
}

// ContractMockListOrderParams contains parameters of the Contract.ListOrder
type ContractMockListOrderParams struct {
	ctx     context.Context
	orderID int64
}

// ContractMockListOrderResults contains results of the Contract.ListOrder
type ContractMockListOrderResults struct {
	l1  model.ListOrder
	err error
}

// Expect sets up expected params for Contract.ListOrder
func (mmListOrder *mContractMockListOrder) Expect(ctx context.Context, orderID int64) *mContractMockListOrder {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("ContractMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &ContractMockListOrderExpectation{}
	}

	mmListOrder.defaultExpectation.params = &ContractMockListOrderParams{ctx, orderID}
	for _, e := range mmListOrder.expectations {
		if minimock.Equal(e.params, mmListOrder.defaultExpectation.params) {
			mmListOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrder.defaultExpectation.params)
		}
	}

	return mmListOrder
}

// Inspect accepts an inspector function that has same arguments as the Contract.ListOrder
func (mmListOrder *mContractMockListOrder) Inspect(f func(ctx context.Context, orderID int64)) *mContractMockListOrder {
	if mmListOrder.mock.inspectFuncListOrder != nil {
		mmListOrder.mock.t.Fatalf("Inspect function is already set for ContractMock.ListOrder")
	}

	mmListOrder.mock.inspectFuncListOrder = f

	return mmListOrder
}

// Return sets up results that will be returned by Contract.ListOrder
func (mmListOrder *mContractMockListOrder) Return(l1 model.ListOrder, err error) *ContractMock {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("ContractMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &ContractMockListOrderExpectation{mock: mmListOrder.mock}
	}
	mmListOrder.defaultExpectation.results = &ContractMockListOrderResults{l1, err}
	return mmListOrder.mock
}

// Set uses given function f to mock the Contract.ListOrder method
func (mmListOrder *mContractMockListOrder) Set(f func(ctx context.Context, orderID int64) (l1 model.ListOrder, err error)) *ContractMock {
	if mmListOrder.defaultExpectation != nil {
		mmListOrder.mock.t.Fatalf("Default expectation is already set for the Contract.ListOrder method")
	}

	if len(mmListOrder.expectations) > 0 {
		mmListOrder.mock.t.Fatalf("Some expectations are already set for the Contract.ListOrder method")
	}

	mmListOrder.mock.funcListOrder = f
	return mmListOrder.mock
}

// When sets expectation for the Contract.ListOrder which will trigger the result defined by the following
// Then helper
func (mmListOrder *mContractMockListOrder) When(ctx context.Context, orderID int64) *ContractMockListOrderExpectation {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("ContractMock.ListOrder mock is already set by Set")
	}

	expectation := &ContractMockListOrderExpectation{
		mock:   mmListOrder.mock,
		params: &ContractMockListOrderParams{ctx, orderID},
	}
	mmListOrder.expectations = append(mmListOrder.expectations, expectation)
	return expectation
}

// Then sets up Contract.ListOrder return parameters for the expectation previously defined by the When method
func (e *ContractMockListOrderExpectation) Then(l1 model.ListOrder, err error) *ContractMock {
	e.results = &ContractMockListOrderResults{l1, err}
	return e.mock
}

// ListOrder implements postgres.Contract
func (mmListOrder *ContractMock) ListOrder(ctx context.Context, orderID int64) (l1 model.ListOrder, err error) {
	mm_atomic.AddUint64(&mmListOrder.beforeListOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrder.afterListOrderCounter, 1)

	if mmListOrder.inspectFuncListOrder != nil {
		mmListOrder.inspectFuncListOrder(ctx, orderID)
	}

	mm_params := &ContractMockListOrderParams{ctx, orderID}

	// Record call args
	mmListOrder.ListOrderMock.mutex.Lock()
	mmListOrder.ListOrderMock.callArgs = append(mmListOrder.ListOrderMock.callArgs, mm_params)
	mmListOrder.ListOrderMock.mutex.Unlock()

	for _, e := range mmListOrder.ListOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmListOrder.ListOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrder.ListOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrder.ListOrderMock.defaultExpectation.params
		mm_got := ContractMockListOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrder.t.Errorf("ContractMock.ListOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrder.ListOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrder.t.Fatal("No results are set for the ContractMock.ListOrder")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmListOrder.funcListOrder != nil {
		return mmListOrder.funcListOrder(ctx, orderID)
	}
	mmListOrder.t.Fatalf("Unexpected call to ContractMock.ListOrder. %v %v", ctx, orderID)
	return
}

// ListOrderAfterCounter returns a count of finished ContractMock.ListOrder invocations
func (mmListOrder *ContractMock) ListOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.afterListOrderCounter)
}

// ListOrderBeforeCounter returns a count of ContractMock.ListOrder invocations
func (mmListOrder *ContractMock) ListOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.beforeListOrderCounter)
}

// Calls returns a list of arguments used in each call to ContractMock.ListOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrder *mContractMockListOrder) Calls() []*ContractMockListOrderParams {
	mmListOrder.mutex.RLock()

	argCopy := make([]*ContractMockListOrderParams, len(mmListOrder.callArgs))
	copy(argCopy, mmListOrder.callArgs)

	mmListOrder.mutex.RUnlock()

	return argCopy
}

// MinimockListOrderDone returns true if the count of the ListOrder invocations corresponds
// the number of defined expectations
func (m *ContractMock) MinimockListOrderDone() bool {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrderInspect logs each unmet expectation
func (m *ContractMock) MinimockListOrderInspect() {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractMock.ListOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		if m.ListOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractMock.ListOrder")
		} else {
			m.t.Errorf("Expected call to ContractMock.ListOrder with params: %#v", *m.ListOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		m.t.Error("Expected call to ContractMock.ListOrder")
	}
}

type mContractMockReserveStocks struct {
	mock               *ContractMock
	defaultExpectation *ContractMockReserveStocksExpectation
	expectations       []*ContractMockReserveStocksExpectation

	callArgs []*ContractMockReserveStocksParams
	mutex    sync.RWMutex
}

// ContractMockReserveStocksExpectation specifies expectation struct of the Contract.ReserveStocks
type ContractMockReserveStocksExpectation struct {
	mock    *ContractMock
	params  *ContractMockReserveStocksParams
	results *ContractMockReserveStocksResults
	Counter uint64
}

// ContractMockReserveStocksParams contains parameters of the Contract.ReserveStocks
type ContractMockReserveStocksParams struct {
	ctx           context.Context
	orderId       int64
	reserveStocks []model.Stock
}

// ContractMockReserveStocksResults contains results of the Contract.ReserveStocks
type ContractMockReserveStocksResults struct {
	err error
}

// Expect sets up expected params for Contract.ReserveStocks
func (mmReserveStocks *mContractMockReserveStocks) Expect(ctx context.Context, orderId int64, reserveStocks []model.Stock) *mContractMockReserveStocks {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("ContractMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &ContractMockReserveStocksExpectation{}
	}

	mmReserveStocks.defaultExpectation.params = &ContractMockReserveStocksParams{ctx, orderId, reserveStocks}
	for _, e := range mmReserveStocks.expectations {
		if minimock.Equal(e.params, mmReserveStocks.defaultExpectation.params) {
			mmReserveStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveStocks.defaultExpectation.params)
		}
	}

	return mmReserveStocks
}

// Inspect accepts an inspector function that has same arguments as the Contract.ReserveStocks
func (mmReserveStocks *mContractMockReserveStocks) Inspect(f func(ctx context.Context, orderId int64, reserveStocks []model.Stock)) *mContractMockReserveStocks {
	if mmReserveStocks.mock.inspectFuncReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("Inspect function is already set for ContractMock.ReserveStocks")
	}

	mmReserveStocks.mock.inspectFuncReserveStocks = f

	return mmReserveStocks
}

// Return sets up results that will be returned by Contract.ReserveStocks
func (mmReserveStocks *mContractMockReserveStocks) Return(err error) *ContractMock {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("ContractMock.ReserveStocks mock is already set by Set")
	}

	if mmReserveStocks.defaultExpectation == nil {
		mmReserveStocks.defaultExpectation = &ContractMockReserveStocksExpectation{mock: mmReserveStocks.mock}
	}
	mmReserveStocks.defaultExpectation.results = &ContractMockReserveStocksResults{err}
	return mmReserveStocks.mock
}

// Set uses given function f to mock the Contract.ReserveStocks method
func (mmReserveStocks *mContractMockReserveStocks) Set(f func(ctx context.Context, orderId int64, reserveStocks []model.Stock) (err error)) *ContractMock {
	if mmReserveStocks.defaultExpectation != nil {
		mmReserveStocks.mock.t.Fatalf("Default expectation is already set for the Contract.ReserveStocks method")
	}

	if len(mmReserveStocks.expectations) > 0 {
		mmReserveStocks.mock.t.Fatalf("Some expectations are already set for the Contract.ReserveStocks method")
	}

	mmReserveStocks.mock.funcReserveStocks = f
	return mmReserveStocks.mock
}

// When sets expectation for the Contract.ReserveStocks which will trigger the result defined by the following
// Then helper
func (mmReserveStocks *mContractMockReserveStocks) When(ctx context.Context, orderId int64, reserveStocks []model.Stock) *ContractMockReserveStocksExpectation {
	if mmReserveStocks.mock.funcReserveStocks != nil {
		mmReserveStocks.mock.t.Fatalf("ContractMock.ReserveStocks mock is already set by Set")
	}

	expectation := &ContractMockReserveStocksExpectation{
		mock:   mmReserveStocks.mock,
		params: &ContractMockReserveStocksParams{ctx, orderId, reserveStocks},
	}
	mmReserveStocks.expectations = append(mmReserveStocks.expectations, expectation)
	return expectation
}

// Then sets up Contract.ReserveStocks return parameters for the expectation previously defined by the When method
func (e *ContractMockReserveStocksExpectation) Then(err error) *ContractMock {
	e.results = &ContractMockReserveStocksResults{err}
	return e.mock
}

// ReserveStocks implements postgres.Contract
func (mmReserveStocks *ContractMock) ReserveStocks(ctx context.Context, orderId int64, reserveStocks []model.Stock) (err error) {
	mm_atomic.AddUint64(&mmReserveStocks.beforeReserveStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveStocks.afterReserveStocksCounter, 1)

	if mmReserveStocks.inspectFuncReserveStocks != nil {
		mmReserveStocks.inspectFuncReserveStocks(ctx, orderId, reserveStocks)
	}

	mm_params := &ContractMockReserveStocksParams{ctx, orderId, reserveStocks}

	// Record call args
	mmReserveStocks.ReserveStocksMock.mutex.Lock()
	mmReserveStocks.ReserveStocksMock.callArgs = append(mmReserveStocks.ReserveStocksMock.callArgs, mm_params)
	mmReserveStocks.ReserveStocksMock.mutex.Unlock()

	for _, e := range mmReserveStocks.ReserveStocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveStocks.ReserveStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveStocks.ReserveStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveStocks.ReserveStocksMock.defaultExpectation.params
		mm_got := ContractMockReserveStocksParams{ctx, orderId, reserveStocks}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveStocks.t.Errorf("ContractMock.ReserveStocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveStocks.ReserveStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveStocks.t.Fatal("No results are set for the ContractMock.ReserveStocks")
		}
		return (*mm_results).err
	}
	if mmReserveStocks.funcReserveStocks != nil {
		return mmReserveStocks.funcReserveStocks(ctx, orderId, reserveStocks)
	}
	mmReserveStocks.t.Fatalf("Unexpected call to ContractMock.ReserveStocks. %v %v %v", ctx, orderId, reserveStocks)
	return
}

// ReserveStocksAfterCounter returns a count of finished ContractMock.ReserveStocks invocations
func (mmReserveStocks *ContractMock) ReserveStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStocks.afterReserveStocksCounter)
}

// ReserveStocksBeforeCounter returns a count of ContractMock.ReserveStocks invocations
func (mmReserveStocks *ContractMock) ReserveStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveStocks.beforeReserveStocksCounter)
}

// Calls returns a list of arguments used in each call to ContractMock.ReserveStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveStocks *mContractMockReserveStocks) Calls() []*ContractMockReserveStocksParams {
	mmReserveStocks.mutex.RLock()

	argCopy := make([]*ContractMockReserveStocksParams, len(mmReserveStocks.callArgs))
	copy(argCopy, mmReserveStocks.callArgs)

	mmReserveStocks.mutex.RUnlock()

	return argCopy
}

// MinimockReserveStocksDone returns true if the count of the ReserveStocks invocations corresponds
// the number of defined expectations
func (m *ContractMock) MinimockReserveStocksDone() bool {
	for _, e := range m.ReserveStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveStocks != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockReserveStocksInspect logs each unmet expectation
func (m *ContractMock) MinimockReserveStocksInspect() {
	for _, e := range m.ReserveStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractMock.ReserveStocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveStocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		if m.ReserveStocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractMock.ReserveStocks")
		} else {
			m.t.Errorf("Expected call to ContractMock.ReserveStocks with params: %#v", *m.ReserveStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveStocks != nil && mm_atomic.LoadUint64(&m.afterReserveStocksCounter) < 1 {
		m.t.Error("Expected call to ContractMock.ReserveStocks")
	}
}

type mContractMockUpdateOrderStatus struct {
	mock               *ContractMock
	defaultExpectation *ContractMockUpdateOrderStatusExpectation
	expectations       []*ContractMockUpdateOrderStatusExpectation

	callArgs []*ContractMockUpdateOrderStatusParams
	mutex    sync.RWMutex
}

// ContractMockUpdateOrderStatusExpectation specifies expectation struct of the Contract.UpdateOrderStatus
type ContractMockUpdateOrderStatusExpectation struct {
	mock    *ContractMock
	params  *ContractMockUpdateOrderStatusParams
	results *ContractMockUpdateOrderStatusResults
	Counter uint64
}

// ContractMockUpdateOrderStatusParams contains parameters of the Contract.UpdateOrderStatus
type ContractMockUpdateOrderStatusParams struct {
	ctx     context.Context
	orderID int64
	status  model.StatusOrder
}

// ContractMockUpdateOrderStatusResults contains results of the Contract.UpdateOrderStatus
type ContractMockUpdateOrderStatusResults struct {
	err error
}

// Expect sets up expected params for Contract.UpdateOrderStatus
func (mmUpdateOrderStatus *mContractMockUpdateOrderStatus) Expect(ctx context.Context, orderID int64, status model.StatusOrder) *mContractMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("ContractMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &ContractMockUpdateOrderStatusExpectation{}
	}

	mmUpdateOrderStatus.defaultExpectation.params = &ContractMockUpdateOrderStatusParams{ctx, orderID, status}
	for _, e := range mmUpdateOrderStatus.expectations {
		if minimock.Equal(e.params, mmUpdateOrderStatus.defaultExpectation.params) {
			mmUpdateOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderStatus.defaultExpectation.params)
		}
	}

	return mmUpdateOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the Contract.UpdateOrderStatus
func (mmUpdateOrderStatus *mContractMockUpdateOrderStatus) Inspect(f func(ctx context.Context, orderID int64, status model.StatusOrder)) *mContractMockUpdateOrderStatus {
	if mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Inspect function is already set for ContractMock.UpdateOrderStatus")
	}

	mmUpdateOrderStatus.mock.inspectFuncUpdateOrderStatus = f

	return mmUpdateOrderStatus
}

// Return sets up results that will be returned by Contract.UpdateOrderStatus
func (mmUpdateOrderStatus *mContractMockUpdateOrderStatus) Return(err error) *ContractMock {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("ContractMock.UpdateOrderStatus mock is already set by Set")
	}

	if mmUpdateOrderStatus.defaultExpectation == nil {
		mmUpdateOrderStatus.defaultExpectation = &ContractMockUpdateOrderStatusExpectation{mock: mmUpdateOrderStatus.mock}
	}
	mmUpdateOrderStatus.defaultExpectation.results = &ContractMockUpdateOrderStatusResults{err}
	return mmUpdateOrderStatus.mock
}

// Set uses given function f to mock the Contract.UpdateOrderStatus method
func (mmUpdateOrderStatus *mContractMockUpdateOrderStatus) Set(f func(ctx context.Context, orderID int64, status model.StatusOrder) (err error)) *ContractMock {
	if mmUpdateOrderStatus.defaultExpectation != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("Default expectation is already set for the Contract.UpdateOrderStatus method")
	}

	if len(mmUpdateOrderStatus.expectations) > 0 {
		mmUpdateOrderStatus.mock.t.Fatalf("Some expectations are already set for the Contract.UpdateOrderStatus method")
	}

	mmUpdateOrderStatus.mock.funcUpdateOrderStatus = f
	return mmUpdateOrderStatus.mock
}

// When sets expectation for the Contract.UpdateOrderStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderStatus *mContractMockUpdateOrderStatus) When(ctx context.Context, orderID int64, status model.StatusOrder) *ContractMockUpdateOrderStatusExpectation {
	if mmUpdateOrderStatus.mock.funcUpdateOrderStatus != nil {
		mmUpdateOrderStatus.mock.t.Fatalf("ContractMock.UpdateOrderStatus mock is already set by Set")
	}

	expectation := &ContractMockUpdateOrderStatusExpectation{
		mock:   mmUpdateOrderStatus.mock,
		params: &ContractMockUpdateOrderStatusParams{ctx, orderID, status},
	}
	mmUpdateOrderStatus.expectations = append(mmUpdateOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up Contract.UpdateOrderStatus return parameters for the expectation previously defined by the When method
func (e *ContractMockUpdateOrderStatusExpectation) Then(err error) *ContractMock {
	e.results = &ContractMockUpdateOrderStatusResults{err}
	return e.mock
}

// UpdateOrderStatus implements postgres.Contract
func (mmUpdateOrderStatus *ContractMock) UpdateOrderStatus(ctx context.Context, orderID int64, status model.StatusOrder) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter, 1)

	if mmUpdateOrderStatus.inspectFuncUpdateOrderStatus != nil {
		mmUpdateOrderStatus.inspectFuncUpdateOrderStatus(ctx, orderID, status)
	}

	mm_params := &ContractMockUpdateOrderStatusParams{ctx, orderID, status}

	// Record call args
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Lock()
	mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs = append(mmUpdateOrderStatus.UpdateOrderStatusMock.callArgs, mm_params)
	mmUpdateOrderStatus.UpdateOrderStatusMock.mutex.Unlock()

	for _, e := range mmUpdateOrderStatus.UpdateOrderStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.params
		mm_got := ContractMockUpdateOrderStatusParams{ctx, orderID, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderStatus.t.Errorf("ContractMock.UpdateOrderStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderStatus.UpdateOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderStatus.t.Fatal("No results are set for the ContractMock.UpdateOrderStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderStatus.funcUpdateOrderStatus != nil {
		return mmUpdateOrderStatus.funcUpdateOrderStatus(ctx, orderID, status)
	}
	mmUpdateOrderStatus.t.Fatalf("Unexpected call to ContractMock.UpdateOrderStatus. %v %v %v", ctx, orderID, status)
	return
}

// UpdateOrderStatusAfterCounter returns a count of finished ContractMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *ContractMock) UpdateOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.afterUpdateOrderStatusCounter)
}

// UpdateOrderStatusBeforeCounter returns a count of ContractMock.UpdateOrderStatus invocations
func (mmUpdateOrderStatus *ContractMock) UpdateOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatus.beforeUpdateOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to ContractMock.UpdateOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderStatus *mContractMockUpdateOrderStatus) Calls() []*ContractMockUpdateOrderStatusParams {
	mmUpdateOrderStatus.mutex.RLock()

	argCopy := make([]*ContractMockUpdateOrderStatusParams, len(mmUpdateOrderStatus.callArgs))
	copy(argCopy, mmUpdateOrderStatus.callArgs)

	mmUpdateOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderStatusDone returns true if the count of the UpdateOrderStatus invocations corresponds
// the number of defined expectations
func (m *ContractMock) MinimockUpdateOrderStatusDone() bool {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderStatusInspect logs each unmet expectation
func (m *ContractMock) MinimockUpdateOrderStatusInspect() {
	for _, e := range m.UpdateOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractMock.UpdateOrderStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		if m.UpdateOrderStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractMock.UpdateOrderStatus")
		} else {
			m.t.Errorf("Expected call to ContractMock.UpdateOrderStatus with params: %#v", *m.UpdateOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusCounter) < 1 {
		m.t.Error("Expected call to ContractMock.UpdateOrderStatus")
	}
}

type mContractMockUpdateStocksReservationStatus struct {
	mock               *ContractMock
	defaultExpectation *ContractMockUpdateStocksReservationStatusExpectation
	expectations       []*ContractMockUpdateStocksReservationStatusExpectation

	callArgs []*ContractMockUpdateStocksReservationStatusParams
	mutex    sync.RWMutex
}

// ContractMockUpdateStocksReservationStatusExpectation specifies expectation struct of the Contract.UpdateStocksReservationStatus
type ContractMockUpdateStocksReservationStatusExpectation struct {
	mock    *ContractMock
	params  *ContractMockUpdateStocksReservationStatusParams
	results *ContractMockUpdateStocksReservationStatusResults
	Counter uint64
}

// ContractMockUpdateStocksReservationStatusParams contains parameters of the Contract.UpdateStocksReservationStatus
type ContractMockUpdateStocksReservationStatusParams struct {
	ctx     context.Context
	orderID int64
	status  model.StatusStockReservation
}

// ContractMockUpdateStocksReservationStatusResults contains results of the Contract.UpdateStocksReservationStatus
type ContractMockUpdateStocksReservationStatusResults struct {
	err error
}

// Expect sets up expected params for Contract.UpdateStocksReservationStatus
func (mmUpdateStocksReservationStatus *mContractMockUpdateStocksReservationStatus) Expect(ctx context.Context, orderID int64, status model.StatusStockReservation) *mContractMockUpdateStocksReservationStatus {
	if mmUpdateStocksReservationStatus.mock.funcUpdateStocksReservationStatus != nil {
		mmUpdateStocksReservationStatus.mock.t.Fatalf("ContractMock.UpdateStocksReservationStatus mock is already set by Set")
	}

	if mmUpdateStocksReservationStatus.defaultExpectation == nil {
		mmUpdateStocksReservationStatus.defaultExpectation = &ContractMockUpdateStocksReservationStatusExpectation{}
	}

	mmUpdateStocksReservationStatus.defaultExpectation.params = &ContractMockUpdateStocksReservationStatusParams{ctx, orderID, status}
	for _, e := range mmUpdateStocksReservationStatus.expectations {
		if minimock.Equal(e.params, mmUpdateStocksReservationStatus.defaultExpectation.params) {
			mmUpdateStocksReservationStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStocksReservationStatus.defaultExpectation.params)
		}
	}

	return mmUpdateStocksReservationStatus
}

// Inspect accepts an inspector function that has same arguments as the Contract.UpdateStocksReservationStatus
func (mmUpdateStocksReservationStatus *mContractMockUpdateStocksReservationStatus) Inspect(f func(ctx context.Context, orderID int64, status model.StatusStockReservation)) *mContractMockUpdateStocksReservationStatus {
	if mmUpdateStocksReservationStatus.mock.inspectFuncUpdateStocksReservationStatus != nil {
		mmUpdateStocksReservationStatus.mock.t.Fatalf("Inspect function is already set for ContractMock.UpdateStocksReservationStatus")
	}

	mmUpdateStocksReservationStatus.mock.inspectFuncUpdateStocksReservationStatus = f

	return mmUpdateStocksReservationStatus
}

// Return sets up results that will be returned by Contract.UpdateStocksReservationStatus
func (mmUpdateStocksReservationStatus *mContractMockUpdateStocksReservationStatus) Return(err error) *ContractMock {
	if mmUpdateStocksReservationStatus.mock.funcUpdateStocksReservationStatus != nil {
		mmUpdateStocksReservationStatus.mock.t.Fatalf("ContractMock.UpdateStocksReservationStatus mock is already set by Set")
	}

	if mmUpdateStocksReservationStatus.defaultExpectation == nil {
		mmUpdateStocksReservationStatus.defaultExpectation = &ContractMockUpdateStocksReservationStatusExpectation{mock: mmUpdateStocksReservationStatus.mock}
	}
	mmUpdateStocksReservationStatus.defaultExpectation.results = &ContractMockUpdateStocksReservationStatusResults{err}
	return mmUpdateStocksReservationStatus.mock
}

// Set uses given function f to mock the Contract.UpdateStocksReservationStatus method
func (mmUpdateStocksReservationStatus *mContractMockUpdateStocksReservationStatus) Set(f func(ctx context.Context, orderID int64, status model.StatusStockReservation) (err error)) *ContractMock {
	if mmUpdateStocksReservationStatus.defaultExpectation != nil {
		mmUpdateStocksReservationStatus.mock.t.Fatalf("Default expectation is already set for the Contract.UpdateStocksReservationStatus method")
	}

	if len(mmUpdateStocksReservationStatus.expectations) > 0 {
		mmUpdateStocksReservationStatus.mock.t.Fatalf("Some expectations are already set for the Contract.UpdateStocksReservationStatus method")
	}

	mmUpdateStocksReservationStatus.mock.funcUpdateStocksReservationStatus = f
	return mmUpdateStocksReservationStatus.mock
}

// When sets expectation for the Contract.UpdateStocksReservationStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateStocksReservationStatus *mContractMockUpdateStocksReservationStatus) When(ctx context.Context, orderID int64, status model.StatusStockReservation) *ContractMockUpdateStocksReservationStatusExpectation {
	if mmUpdateStocksReservationStatus.mock.funcUpdateStocksReservationStatus != nil {
		mmUpdateStocksReservationStatus.mock.t.Fatalf("ContractMock.UpdateStocksReservationStatus mock is already set by Set")
	}

	expectation := &ContractMockUpdateStocksReservationStatusExpectation{
		mock:   mmUpdateStocksReservationStatus.mock,
		params: &ContractMockUpdateStocksReservationStatusParams{ctx, orderID, status},
	}
	mmUpdateStocksReservationStatus.expectations = append(mmUpdateStocksReservationStatus.expectations, expectation)
	return expectation
}

// Then sets up Contract.UpdateStocksReservationStatus return parameters for the expectation previously defined by the When method
func (e *ContractMockUpdateStocksReservationStatusExpectation) Then(err error) *ContractMock {
	e.results = &ContractMockUpdateStocksReservationStatusResults{err}
	return e.mock
}

// UpdateStocksReservationStatus implements postgres.Contract
func (mmUpdateStocksReservationStatus *ContractMock) UpdateStocksReservationStatus(ctx context.Context, orderID int64, status model.StatusStockReservation) (err error) {
	mm_atomic.AddUint64(&mmUpdateStocksReservationStatus.beforeUpdateStocksReservationStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStocksReservationStatus.afterUpdateStocksReservationStatusCounter, 1)

	if mmUpdateStocksReservationStatus.inspectFuncUpdateStocksReservationStatus != nil {
		mmUpdateStocksReservationStatus.inspectFuncUpdateStocksReservationStatus(ctx, orderID, status)
	}

	mm_params := &ContractMockUpdateStocksReservationStatusParams{ctx, orderID, status}

	// Record call args
	mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.mutex.Lock()
	mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.callArgs = append(mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.callArgs, mm_params)
	mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.mutex.Unlock()

	for _, e := range mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.defaultExpectation.params
		mm_got := ContractMockUpdateStocksReservationStatusParams{ctx, orderID, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStocksReservationStatus.t.Errorf("ContractMock.UpdateStocksReservationStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStocksReservationStatus.UpdateStocksReservationStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStocksReservationStatus.t.Fatal("No results are set for the ContractMock.UpdateStocksReservationStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateStocksReservationStatus.funcUpdateStocksReservationStatus != nil {
		return mmUpdateStocksReservationStatus.funcUpdateStocksReservationStatus(ctx, orderID, status)
	}
	mmUpdateStocksReservationStatus.t.Fatalf("Unexpected call to ContractMock.UpdateStocksReservationStatus. %v %v %v", ctx, orderID, status)
	return
}

// UpdateStocksReservationStatusAfterCounter returns a count of finished ContractMock.UpdateStocksReservationStatus invocations
func (mmUpdateStocksReservationStatus *ContractMock) UpdateStocksReservationStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStocksReservationStatus.afterUpdateStocksReservationStatusCounter)
}

// UpdateStocksReservationStatusBeforeCounter returns a count of ContractMock.UpdateStocksReservationStatus invocations
func (mmUpdateStocksReservationStatus *ContractMock) UpdateStocksReservationStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStocksReservationStatus.beforeUpdateStocksReservationStatusCounter)
}

// Calls returns a list of arguments used in each call to ContractMock.UpdateStocksReservationStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStocksReservationStatus *mContractMockUpdateStocksReservationStatus) Calls() []*ContractMockUpdateStocksReservationStatusParams {
	mmUpdateStocksReservationStatus.mutex.RLock()

	argCopy := make([]*ContractMockUpdateStocksReservationStatusParams, len(mmUpdateStocksReservationStatus.callArgs))
	copy(argCopy, mmUpdateStocksReservationStatus.callArgs)

	mmUpdateStocksReservationStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStocksReservationStatusDone returns true if the count of the UpdateStocksReservationStatus invocations corresponds
// the number of defined expectations
func (m *ContractMock) MinimockUpdateStocksReservationStatusDone() bool {
	for _, e := range m.UpdateStocksReservationStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStocksReservationStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStocksReservationStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStocksReservationStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateStocksReservationStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateStocksReservationStatusInspect logs each unmet expectation
func (m *ContractMock) MinimockUpdateStocksReservationStatusInspect() {
	for _, e := range m.UpdateStocksReservationStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContractMock.UpdateStocksReservationStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStocksReservationStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStocksReservationStatusCounter) < 1 {
		if m.UpdateStocksReservationStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContractMock.UpdateStocksReservationStatus")
		} else {
			m.t.Errorf("Expected call to ContractMock.UpdateStocksReservationStatus with params: %#v", *m.UpdateStocksReservationStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStocksReservationStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateStocksReservationStatusCounter) < 1 {
		m.t.Error("Expected call to ContractMock.UpdateStocksReservationStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContractMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCntStocksInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockListOrderInspect()

		m.MinimockReserveStocksInspect()

		m.MinimockUpdateOrderStatusInspect()

		m.MinimockUpdateStocksReservationStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContractMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContractMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCntStocksDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockListOrderDone() &&
		m.MinimockReserveStocksDone() &&
		m.MinimockUpdateOrderStatusDone() &&
		m.MinimockUpdateStocksReservationStatusDone()
}
